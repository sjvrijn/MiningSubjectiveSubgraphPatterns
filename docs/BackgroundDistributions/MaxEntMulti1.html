<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.3" />
<title>src.BackgroundDistributions.MaxEntMulti1 API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/highlight.min.js" integrity="sha256-eOgo0OtLL4cdq7RdwRUiGKLX9XsIJ7nGhWEKbohmVAQ=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>src.BackgroundDistributions.MaxEntMulti1</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">###################################################################################################################################################################
###################################################################################################################################################################
###################################################################################################################################################################
###################################################################################################################################################################
import numpy as np
import networkx as nx
import math
import os
import sys
path = os.getcwd().split(&#39;MiningSubjectiveSubgraphPatterns&#39;)[0]+&#39;MiningSubjectiveSubgraphPatterns/&#39;
if path not in sys.path:
        sys.path.append(path)
from src.BackgroundDistributions.PDClass import PDClass
###################################################################################################################################################################
class MaxEntMulti1U(PDClass):
    &#34;&#34;&#34;
    Background distribution for multigraphs if type of prior belief is &#39;i&#39; and type of graph is &#39;undirected&#39;

    Parameters
    ----------
    PDClass : src.BackgroundDistributions.PDClass
        base class
    &#34;&#34;&#34;
    def __init__(self, G = None):
        super().__init__(G)
        self.la = None
        self.jrows = None
        self.errors = None
        self.ps = None
        self.gla = None
        self.lprevUpdate = {}
        self.degrees = None
        if G is not None:
            self.findMaxEntDistribution()
###################################################################################################################################################################
    def findMaxEntDistribution(self):
        self.degrees = np.array(list(dict(sorted(dict(self.G.degree()).items())).values()))
        n = len(self.degrees)
        ######################
        prows = self.degrees/n
        prowsunique,irows,self.jrows,vrows = np.unique(prows, return_index=True, return_inverse=True, return_counts=True)
        nunique = len(prowsunique)
        bins = np.zeros(nunique)
        if irows[0] == 1:
            bins[0] == 1
        for i in range(1, nunique):
            if irows[i-1] == irows[i]-1:
                bins[i] = 1
        self.la = -np.ones(nunique)
        h = np.zeros(nunique)
        nit = 1000
        tol = 1e-14
        self.errors = np.empty(0)
        ######################
        lb = -5
        for k in range(nit):
            E = np.multiply(np.outer(np.ones(nunique).T, np.exp(self.la/2)),np.outer(np.exp(self.la/2), np.ones(nunique).T))
            ps = np.divide(E, 1-E)
            self.gla = np.multiply(-n*prowsunique+np.dot(ps, vrows)-np.diag(ps), vrows)
            self.errors = np.append(self.errors, np.linalg.norm(self.gla))

            H = 1/2*np.dot(np.dot(np.diag(vrows), np.divide(E, np.square(1-E))), np.diag(vrows))
            H = H + np.diag(np.sum(H, 0)) - 2*np.diag(np.divide(np.diag(H), vrows))
            H = H + np.dot(np.trace(H) / nunique,1e-10)

            deltala = np.linalg.solve(- H,self.gla)

            fbest = 0;
            errorbest = self.errors[k];

            for f in np.logspace(lb,1,20):
                latry=self.la+f*deltala
                Etry = np.multiply(np.outer(np.ones(nunique).T, np.exp(latry/2)),np.outer(np.exp(latry/2), np.ones(nunique).T))
                if np.max(np.max(Etry - np.diag(np.multiply(bins, np.diag(Etry))))) &gt;= 1:
                    break
                pstry = np.divide(Etry, 1-Etry)
                glatry = np.multiply(-n*prowsunique+np.dot(pstry, vrows)-np.diag(pstry), vrows)
                errortry = np.linalg.norm(glatry)
                if errortry &lt; errorbest:
                    fbest = f
                    errorbest = errortry
            if fbest == 0:
                if lb&gt;-1000:
                    lb = lb*2
                else:
                    break

            self.la = self.la+fbest*deltala;

            if self.errors[k]/n &lt; tol:
                break

        E = np.multiply(np.outer(np.ones(nunique).T, np.exp(self.la/2)),np.outer(np.exp(self.la/2), np.ones(nunique).T))
        self.ps = np.divide(E, 1-E)
        self.gla = np.multiply(-n*prowsunique+np.dot(self.ps, vrows)-np.diag(self.ps), vrows)
        self.errors = np.append(self.errors, np.linalg.norm(self.gla))
###################################################################################################################################################################
    def getAB(self):
        mSmallestLambda = np.min(self.la)
        mLargestLambda = np.max(self.la)

        epsilon = 1e-8

        if math.fabs(mSmallestLambda) &gt; math.fabs(mLargestLambda):
            a = epsilon
            b = 3*math.fabs(mSmallestLambda)
        else:
            a = epsilon
            b = 3*math.fabs(mLargestLambda)
        return a,b
###################################################################################################################################################################
    def getExpectationFromExpLambda(self, a):
        if 1-a &lt; 1e-10:
            return 1e10
        return a/(1-a)
###################################################################################################################################################################
    def getExpectationFromPOS(self, a):
        return (1-a)/a
###################################################################################################################################################################
    def getExpectation(self, i, j, **kwargs):
        if i==j:
            return 0.0
        p = self.getPOS(i, j, **kwargs)
        # if p &lt; 1e-2:
        #     print(i, j, p)
        E = self.getExpectationFromPOS(p)
        return E
###################################################################################################################################################################
    def explambda(self, i, j):
        expL = math.exp(self.la[self.jrows[i]]/2)*math.exp(self.la[self.jrows[j]]/2)
        return expL
###################################################################################################################################################################
###################################################################################################################################################################
###################################################################################################################################################################
###################################################################################################################################################################


class MaxEntMulti1D(PDClass):
    &#34;&#34;&#34;
    Background distribution for multigraphs if type of prior belief is &#39;i&#39; and type of graph is &#39;directed&#39;

    Parameters
    ----------
    PDClass : src.BackgroundDistributions.PDClass
        base class
    &#34;&#34;&#34;
    def __init__(self, G = None):
        super().__init__(G)
        self.tp = &#39;D&#39;
        self.la = None
        self.mu = None
        self.jrows = None
        self.jcols = None
        self.errors = None
        self.ps = None
        self.gla = None
        self.lprevUpdate = {}
        self.indegrees = None
        self.outdegrees = None
        if G is not None:
            self.findMaxEntDistribution()
###################################################################################################################################################################
    def findMaxEntDistribution(self):
        self.indegrees = np.array(list(dict(sorted(dict(self.G.in_degree()).items())).values()))
        self.outdegrees = np.array(list(dict(sorted(dict(self.G.out_degree()).items())).values()))
        n = len(self.indegrees)
        m = len(self.outdegrees)

        fac = math.log(self.density/(1+self.density))

        prows = self.outdegrees
        prowsunique, irows, self.jrows, vrows = np.unique(prows, return_index=True, return_inverse=True, return_counts=True)
        rownunique = len(prowsunique)
        self.la = -math.fabs(fac)*np.ones(rownunique)
        rowh = np.zeros(rownunique)

        pcols = self.indegrees
        pcolsunique, icols, self.jcols, vcols = np.unique(pcols, return_index=True, return_inverse=True, return_counts=True)
        colnunique = len(pcolsunique)
        self.mu = -math.fabs(fac)*np.ones(colnunique)
        colh = np.zeros(colnunique)

        loops = np.outer(np.zeros(rownunique), np.zeros(colnunique).T)

        for i in range(rownunique):
            for j in range(colnunique):
                loops[i][j] = len(set(np.where(self.jrows==i)[0]).intersection(set(np.where(self.jcols==j)[0])))
        finalmat=np.outer(vrows, vcols)-np.array(loops)

        print(&#39;Sizes----Vrows:&#39;,len(vrows),&#39; Vcols&#39;, len(vcols))

        nit = 1000
        tol = 1e-14
        self.errors = np.empty(0)

        lb = -5
        for k in range(nit):
            E = np.multiply(np.outer(np.exp(self.la/2), np.ones(colnunique).T),np.outer(np.ones(rownunique).T, np.exp(self.mu/2)))
            self.ps = np.divide(E, 1-E)

            gla_t = np.multiply(self.ps, finalmat)

            gla_r = np.sum(gla_t, 1) - np.multiply(prowsunique, vrows)
            gla_c = np.sum(gla_t, 0) - np.multiply(pcolsunique, vcols)

            self.gla = np.append(gla_r, gla_c)

            self.errors = np.append(self.errors, np.linalg.norm(self.gla))

            H_t = np.divide(E, np.square(1-E))
            H_t = np.multiply(H_t, finalmat)

            H_r = np.diag(np.sum(H_t,1))
            H_c = np.diag(np.sum(H_t,0))

            H = np.append(np.append(H_r, H_t, 1), np.append(H_t.T, H_c, 1), 0)

            delta = np.linalg.lstsq(- H, self.gla, rcond=max(H.shape)*np.finfo(H.dtype).eps)[0]
            deltala = delta[0:rownunique]
            deltamu = delta[rownunique:rownunique+colnunique+1]
            fbest = 0;
            errorbest = self.errors[k];

            for f in np.logspace(lb,1,20):
                latry=self.la+f*deltala
                mutry=self.mu+f*deltamu
                flag = True
                for ind1 in range(len(latry)):
                    for ind2 in range(len(mutry)):
                        if latry[ind1]+mutry[ind2]&gt;-1e-15 and finalmat[ind1][ind2]&gt;0.0001:
                            flag = False
                if flag:
                    Etry = np.multiply(np.outer(np.exp(latry/2), np.ones(colnunique).T),np.outer(np.ones(rownunique).T, np.exp(mutry/2)))
                    pstry = np.divide(Etry, 1-Etry)

                    gla_ttry = np.multiply(pstry, finalmat)

                    gla_rtry = np.sum(gla_ttry, 1) - np.multiply(prowsunique, vrows)
                    gla_ctry = np.sum(gla_ttry, 0) - np.multiply(pcolsunique, vcols)

                    gla_try = np.append(gla_rtry, gla_ctry)

                    errortry = np.linalg.norm(gla_try)

                    if errortry &lt; errorbest:
                        fbest = f
                        errorbest = errortry
            if fbest == 0:
                if lb&gt;-1000:
                    lb = lb*2
                else:
                    break

            self.la = self.la+fbest*deltala;
            self.mu = self.mu+fbest*deltamu;

            if self.errors[k] &lt; tol:
                break

        E = np.multiply(np.outer(np.exp(self.la/2), np.ones(colnunique).T),np.outer(np.ones(rownunique).T, np.exp(self.mu/2)))
        self.ps = np.divide(E, 1-E)
        gla_t = np.multiply(self.ps, finalmat)

        gla_r = np.sum(gla_t, 1) - np.multiply(prowsunique, vrows)
        gla_c = np.sum(gla_t, 0) - np.multiply(pcolsunique, vcols)

        self.gla = np.append(gla_r, gla_c)

        self.errors = np.append(self.errors, np.linalg.norm(self.gla))
###################################################################################################################################################################
    def getAB(self):
        mSmallestLambda = np.min(np.array(list(set(self.la).union(set(self.mu)))))
        mLargestLambda = np.max(np.array(list(set(self.la).union(set(self.mu)))))

        epsilon = 1e-8

        if math.fabs(mSmallestLambda) &gt; math.fabs(mLargestLambda):
            a = epsilon
            b = 3*math.fabs(mSmallestLambda)
        else:
            a = epsilon
            b = 3*math.fabs(mLargestLambda)
        return a,b
###################################################################################################################################################################
    def getExpectationFromExpLambda(self, a):
        return a/(1-a)
###################################################################################################################################################################
    def getExpectationFromPOS(self, a):
        if a &lt; 1e-10:
            a = 1e-10
        if a &gt; 1.0 - 1e-10:
            a = 1.0 - 1e-10
        return (1-a)/a
###################################################################################################################################################################
    def getExpectation(self, i, j, **kwargs):
        kwargs[&#39;isSimple&#39;] = False
        p = self.getPOS(i, j, **kwargs)
        E = self.getExpectationFromPOS(p)
        return E
###################################################################################################################################################################
    def explambda(self, i, j):
        expL = math.exp(self.la[self.jrows[i]]/2)*math.exp(self.mu[self.jcols[j]]/2)
        return expL
###################################################################################################################################################################
###################################################################################################################################################################
###################################################################################################################################################################
###################################################################################################################################################################</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="src.BackgroundDistributions.MaxEntMulti1.MaxEntMulti1D"><code class="flex name class">
<span>class <span class="ident">MaxEntMulti1D</span></span>
<span>(</span><span>G=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Background distribution for multigraphs if type of prior belief is 'i' and type of graph is 'directed'</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>PDClass</code></strong> :&ensp;<code><a title="src.BackgroundDistributions.PDClass" href="PDClass.html">src.BackgroundDistributions.PDClass</a></code></dt>
<dd>base class</dd>
</dl>
<p>initialization function</p>
<h2 id="parameters_1">Parameters</h2>
<dl>
<dt><strong><code>G</code></strong> :&ensp;<code>networkx graph</code></dt>
<dd>input graph</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MaxEntMulti1D(PDClass):
    &#34;&#34;&#34;
    Background distribution for multigraphs if type of prior belief is &#39;i&#39; and type of graph is &#39;directed&#39;

    Parameters
    ----------
    PDClass : src.BackgroundDistributions.PDClass
        base class
    &#34;&#34;&#34;
    def __init__(self, G = None):
        super().__init__(G)
        self.tp = &#39;D&#39;
        self.la = None
        self.mu = None
        self.jrows = None
        self.jcols = None
        self.errors = None
        self.ps = None
        self.gla = None
        self.lprevUpdate = {}
        self.indegrees = None
        self.outdegrees = None
        if G is not None:
            self.findMaxEntDistribution()
###################################################################################################################################################################
    def findMaxEntDistribution(self):
        self.indegrees = np.array(list(dict(sorted(dict(self.G.in_degree()).items())).values()))
        self.outdegrees = np.array(list(dict(sorted(dict(self.G.out_degree()).items())).values()))
        n = len(self.indegrees)
        m = len(self.outdegrees)

        fac = math.log(self.density/(1+self.density))

        prows = self.outdegrees
        prowsunique, irows, self.jrows, vrows = np.unique(prows, return_index=True, return_inverse=True, return_counts=True)
        rownunique = len(prowsunique)
        self.la = -math.fabs(fac)*np.ones(rownunique)
        rowh = np.zeros(rownunique)

        pcols = self.indegrees
        pcolsunique, icols, self.jcols, vcols = np.unique(pcols, return_index=True, return_inverse=True, return_counts=True)
        colnunique = len(pcolsunique)
        self.mu = -math.fabs(fac)*np.ones(colnunique)
        colh = np.zeros(colnunique)

        loops = np.outer(np.zeros(rownunique), np.zeros(colnunique).T)

        for i in range(rownunique):
            for j in range(colnunique):
                loops[i][j] = len(set(np.where(self.jrows==i)[0]).intersection(set(np.where(self.jcols==j)[0])))
        finalmat=np.outer(vrows, vcols)-np.array(loops)

        print(&#39;Sizes----Vrows:&#39;,len(vrows),&#39; Vcols&#39;, len(vcols))

        nit = 1000
        tol = 1e-14
        self.errors = np.empty(0)

        lb = -5
        for k in range(nit):
            E = np.multiply(np.outer(np.exp(self.la/2), np.ones(colnunique).T),np.outer(np.ones(rownunique).T, np.exp(self.mu/2)))
            self.ps = np.divide(E, 1-E)

            gla_t = np.multiply(self.ps, finalmat)

            gla_r = np.sum(gla_t, 1) - np.multiply(prowsunique, vrows)
            gla_c = np.sum(gla_t, 0) - np.multiply(pcolsunique, vcols)

            self.gla = np.append(gla_r, gla_c)

            self.errors = np.append(self.errors, np.linalg.norm(self.gla))

            H_t = np.divide(E, np.square(1-E))
            H_t = np.multiply(H_t, finalmat)

            H_r = np.diag(np.sum(H_t,1))
            H_c = np.diag(np.sum(H_t,0))

            H = np.append(np.append(H_r, H_t, 1), np.append(H_t.T, H_c, 1), 0)

            delta = np.linalg.lstsq(- H, self.gla, rcond=max(H.shape)*np.finfo(H.dtype).eps)[0]
            deltala = delta[0:rownunique]
            deltamu = delta[rownunique:rownunique+colnunique+1]
            fbest = 0;
            errorbest = self.errors[k];

            for f in np.logspace(lb,1,20):
                latry=self.la+f*deltala
                mutry=self.mu+f*deltamu
                flag = True
                for ind1 in range(len(latry)):
                    for ind2 in range(len(mutry)):
                        if latry[ind1]+mutry[ind2]&gt;-1e-15 and finalmat[ind1][ind2]&gt;0.0001:
                            flag = False
                if flag:
                    Etry = np.multiply(np.outer(np.exp(latry/2), np.ones(colnunique).T),np.outer(np.ones(rownunique).T, np.exp(mutry/2)))
                    pstry = np.divide(Etry, 1-Etry)

                    gla_ttry = np.multiply(pstry, finalmat)

                    gla_rtry = np.sum(gla_ttry, 1) - np.multiply(prowsunique, vrows)
                    gla_ctry = np.sum(gla_ttry, 0) - np.multiply(pcolsunique, vcols)

                    gla_try = np.append(gla_rtry, gla_ctry)

                    errortry = np.linalg.norm(gla_try)

                    if errortry &lt; errorbest:
                        fbest = f
                        errorbest = errortry
            if fbest == 0:
                if lb&gt;-1000:
                    lb = lb*2
                else:
                    break

            self.la = self.la+fbest*deltala;
            self.mu = self.mu+fbest*deltamu;

            if self.errors[k] &lt; tol:
                break

        E = np.multiply(np.outer(np.exp(self.la/2), np.ones(colnunique).T),np.outer(np.ones(rownunique).T, np.exp(self.mu/2)))
        self.ps = np.divide(E, 1-E)
        gla_t = np.multiply(self.ps, finalmat)

        gla_r = np.sum(gla_t, 1) - np.multiply(prowsunique, vrows)
        gla_c = np.sum(gla_t, 0) - np.multiply(pcolsunique, vcols)

        self.gla = np.append(gla_r, gla_c)

        self.errors = np.append(self.errors, np.linalg.norm(self.gla))
###################################################################################################################################################################
    def getAB(self):
        mSmallestLambda = np.min(np.array(list(set(self.la).union(set(self.mu)))))
        mLargestLambda = np.max(np.array(list(set(self.la).union(set(self.mu)))))

        epsilon = 1e-8

        if math.fabs(mSmallestLambda) &gt; math.fabs(mLargestLambda):
            a = epsilon
            b = 3*math.fabs(mSmallestLambda)
        else:
            a = epsilon
            b = 3*math.fabs(mLargestLambda)
        return a,b
###################################################################################################################################################################
    def getExpectationFromExpLambda(self, a):
        return a/(1-a)
###################################################################################################################################################################
    def getExpectationFromPOS(self, a):
        if a &lt; 1e-10:
            a = 1e-10
        if a &gt; 1.0 - 1e-10:
            a = 1.0 - 1e-10
        return (1-a)/a
###################################################################################################################################################################
    def getExpectation(self, i, j, **kwargs):
        kwargs[&#39;isSimple&#39;] = False
        p = self.getPOS(i, j, **kwargs)
        E = self.getExpectationFromPOS(p)
        return E
###################################################################################################################################################################
    def explambda(self, i, j):
        expL = math.exp(self.la[self.jrows[i]]/2)*math.exp(self.mu[self.jcols[j]]/2)
        return expL</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="src.BackgroundDistributions.PDClass.PDClass" href="PDClass.html#src.BackgroundDistributions.PDClass.PDClass">PDClass</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="src.BackgroundDistributions.MaxEntMulti1.MaxEntMulti1D.findMaxEntDistribution"><code class="name flex">
<span>def <span class="ident">findMaxEntDistribution</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def findMaxEntDistribution(self):
    self.indegrees = np.array(list(dict(sorted(dict(self.G.in_degree()).items())).values()))
    self.outdegrees = np.array(list(dict(sorted(dict(self.G.out_degree()).items())).values()))
    n = len(self.indegrees)
    m = len(self.outdegrees)

    fac = math.log(self.density/(1+self.density))

    prows = self.outdegrees
    prowsunique, irows, self.jrows, vrows = np.unique(prows, return_index=True, return_inverse=True, return_counts=True)
    rownunique = len(prowsunique)
    self.la = -math.fabs(fac)*np.ones(rownunique)
    rowh = np.zeros(rownunique)

    pcols = self.indegrees
    pcolsunique, icols, self.jcols, vcols = np.unique(pcols, return_index=True, return_inverse=True, return_counts=True)
    colnunique = len(pcolsunique)
    self.mu = -math.fabs(fac)*np.ones(colnunique)
    colh = np.zeros(colnunique)

    loops = np.outer(np.zeros(rownunique), np.zeros(colnunique).T)

    for i in range(rownunique):
        for j in range(colnunique):
            loops[i][j] = len(set(np.where(self.jrows==i)[0]).intersection(set(np.where(self.jcols==j)[0])))
    finalmat=np.outer(vrows, vcols)-np.array(loops)

    print(&#39;Sizes----Vrows:&#39;,len(vrows),&#39; Vcols&#39;, len(vcols))

    nit = 1000
    tol = 1e-14
    self.errors = np.empty(0)

    lb = -5
    for k in range(nit):
        E = np.multiply(np.outer(np.exp(self.la/2), np.ones(colnunique).T),np.outer(np.ones(rownunique).T, np.exp(self.mu/2)))
        self.ps = np.divide(E, 1-E)

        gla_t = np.multiply(self.ps, finalmat)

        gla_r = np.sum(gla_t, 1) - np.multiply(prowsunique, vrows)
        gla_c = np.sum(gla_t, 0) - np.multiply(pcolsunique, vcols)

        self.gla = np.append(gla_r, gla_c)

        self.errors = np.append(self.errors, np.linalg.norm(self.gla))

        H_t = np.divide(E, np.square(1-E))
        H_t = np.multiply(H_t, finalmat)

        H_r = np.diag(np.sum(H_t,1))
        H_c = np.diag(np.sum(H_t,0))

        H = np.append(np.append(H_r, H_t, 1), np.append(H_t.T, H_c, 1), 0)

        delta = np.linalg.lstsq(- H, self.gla, rcond=max(H.shape)*np.finfo(H.dtype).eps)[0]
        deltala = delta[0:rownunique]
        deltamu = delta[rownunique:rownunique+colnunique+1]
        fbest = 0;
        errorbest = self.errors[k];

        for f in np.logspace(lb,1,20):
            latry=self.la+f*deltala
            mutry=self.mu+f*deltamu
            flag = True
            for ind1 in range(len(latry)):
                for ind2 in range(len(mutry)):
                    if latry[ind1]+mutry[ind2]&gt;-1e-15 and finalmat[ind1][ind2]&gt;0.0001:
                        flag = False
            if flag:
                Etry = np.multiply(np.outer(np.exp(latry/2), np.ones(colnunique).T),np.outer(np.ones(rownunique).T, np.exp(mutry/2)))
                pstry = np.divide(Etry, 1-Etry)

                gla_ttry = np.multiply(pstry, finalmat)

                gla_rtry = np.sum(gla_ttry, 1) - np.multiply(prowsunique, vrows)
                gla_ctry = np.sum(gla_ttry, 0) - np.multiply(pcolsunique, vcols)

                gla_try = np.append(gla_rtry, gla_ctry)

                errortry = np.linalg.norm(gla_try)

                if errortry &lt; errorbest:
                    fbest = f
                    errorbest = errortry
        if fbest == 0:
            if lb&gt;-1000:
                lb = lb*2
            else:
                break

        self.la = self.la+fbest*deltala;
        self.mu = self.mu+fbest*deltamu;

        if self.errors[k] &lt; tol:
            break

    E = np.multiply(np.outer(np.exp(self.la/2), np.ones(colnunique).T),np.outer(np.ones(rownunique).T, np.exp(self.mu/2)))
    self.ps = np.divide(E, 1-E)
    gla_t = np.multiply(self.ps, finalmat)

    gla_r = np.sum(gla_t, 1) - np.multiply(prowsunique, vrows)
    gla_c = np.sum(gla_t, 0) - np.multiply(pcolsunique, vcols)

    self.gla = np.append(gla_r, gla_c)

    self.errors = np.append(self.errors, np.linalg.norm(self.gla))</code></pre>
</details>
</dd>
<dt id="src.BackgroundDistributions.MaxEntMulti1.MaxEntMulti1D.getExpectation"><code class="name flex">
<span>def <span class="ident">getExpectation</span></span>(<span>self, i, j, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getExpectation(self, i, j, **kwargs):
    kwargs[&#39;isSimple&#39;] = False
    p = self.getPOS(i, j, **kwargs)
    E = self.getExpectationFromPOS(p)
    return E</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="src.BackgroundDistributions.PDClass.PDClass" href="PDClass.html#src.BackgroundDistributions.PDClass.PDClass">PDClass</a></b></code>:
<ul class="hlist">
<li><code><a title="src.BackgroundDistributions.PDClass.PDClass.explambda" href="PDClass.html#src.BackgroundDistributions.PDClass.PDClass.explambda">explambda</a></code></li>
<li><code><a title="src.BackgroundDistributions.PDClass.PDClass.explambdaIncLprev" href="PDClass.html#src.BackgroundDistributions.PDClass.PDClass.explambdaIncLprev">explambdaIncLprev</a></code></li>
<li><code><a title="src.BackgroundDistributions.PDClass.PDClass.explambdaIncLprevButDropSomeLas" href="PDClass.html#src.BackgroundDistributions.PDClass.PDClass.explambdaIncLprevButDropSomeLas">explambdaIncLprevButDropSomeLas</a></code></li>
<li><code><a title="src.BackgroundDistributions.PDClass.PDClass.explambdaMultiplier" href="PDClass.html#src.BackgroundDistributions.PDClass.PDClass.explambdaMultiplier">explambdaMultiplier</a></code></li>
<li><code><a title="src.BackgroundDistributions.PDClass.PDClass.findDistribution" href="PDClass.html#src.BackgroundDistributions.PDClass.PDClass.findDistribution">findDistribution</a></code></li>
<li><code><a title="src.BackgroundDistributions.PDClass.PDClass.getAB" href="PDClass.html#src.BackgroundDistributions.PDClass.PDClass.getAB">getAB</a></code></li>
<li><code><a title="src.BackgroundDistributions.PDClass.PDClass.getExpectationFromExpLambda" href="PDClass.html#src.BackgroundDistributions.PDClass.PDClass.getExpectationFromExpLambda">getExpectationFromExpLambda</a></code></li>
<li><code><a title="src.BackgroundDistributions.PDClass.PDClass.getExpectationFromPOS" href="PDClass.html#src.BackgroundDistributions.PDClass.PDClass.getExpectationFromPOS">getExpectationFromPOS</a></code></li>
<li><code><a title="src.BackgroundDistributions.PDClass.PDClass.getPOS" href="PDClass.html#src.BackgroundDistributions.PDClass.PDClass.getPOS">getPOS</a></code></li>
<li><code><a title="src.BackgroundDistributions.PDClass.PDClass.updateDistribution" href="PDClass.html#src.BackgroundDistributions.PDClass.PDClass.updateDistribution">updateDistribution</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="src.BackgroundDistributions.MaxEntMulti1.MaxEntMulti1U"><code class="flex name class">
<span>class <span class="ident">MaxEntMulti1U</span></span>
<span>(</span><span>G=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Background distribution for multigraphs if type of prior belief is 'i' and type of graph is 'undirected'</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>PDClass</code></strong> :&ensp;<code><a title="src.BackgroundDistributions.PDClass" href="PDClass.html">src.BackgroundDistributions.PDClass</a></code></dt>
<dd>base class</dd>
</dl>
<p>initialization function</p>
<h2 id="parameters_1">Parameters</h2>
<dl>
<dt><strong><code>G</code></strong> :&ensp;<code>networkx graph</code></dt>
<dd>input graph</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MaxEntMulti1U(PDClass):
    &#34;&#34;&#34;
    Background distribution for multigraphs if type of prior belief is &#39;i&#39; and type of graph is &#39;undirected&#39;

    Parameters
    ----------
    PDClass : src.BackgroundDistributions.PDClass
        base class
    &#34;&#34;&#34;
    def __init__(self, G = None):
        super().__init__(G)
        self.la = None
        self.jrows = None
        self.errors = None
        self.ps = None
        self.gla = None
        self.lprevUpdate = {}
        self.degrees = None
        if G is not None:
            self.findMaxEntDistribution()
###################################################################################################################################################################
    def findMaxEntDistribution(self):
        self.degrees = np.array(list(dict(sorted(dict(self.G.degree()).items())).values()))
        n = len(self.degrees)
        ######################
        prows = self.degrees/n
        prowsunique,irows,self.jrows,vrows = np.unique(prows, return_index=True, return_inverse=True, return_counts=True)
        nunique = len(prowsunique)
        bins = np.zeros(nunique)
        if irows[0] == 1:
            bins[0] == 1
        for i in range(1, nunique):
            if irows[i-1] == irows[i]-1:
                bins[i] = 1
        self.la = -np.ones(nunique)
        h = np.zeros(nunique)
        nit = 1000
        tol = 1e-14
        self.errors = np.empty(0)
        ######################
        lb = -5
        for k in range(nit):
            E = np.multiply(np.outer(np.ones(nunique).T, np.exp(self.la/2)),np.outer(np.exp(self.la/2), np.ones(nunique).T))
            ps = np.divide(E, 1-E)
            self.gla = np.multiply(-n*prowsunique+np.dot(ps, vrows)-np.diag(ps), vrows)
            self.errors = np.append(self.errors, np.linalg.norm(self.gla))

            H = 1/2*np.dot(np.dot(np.diag(vrows), np.divide(E, np.square(1-E))), np.diag(vrows))
            H = H + np.diag(np.sum(H, 0)) - 2*np.diag(np.divide(np.diag(H), vrows))
            H = H + np.dot(np.trace(H) / nunique,1e-10)

            deltala = np.linalg.solve(- H,self.gla)

            fbest = 0;
            errorbest = self.errors[k];

            for f in np.logspace(lb,1,20):
                latry=self.la+f*deltala
                Etry = np.multiply(np.outer(np.ones(nunique).T, np.exp(latry/2)),np.outer(np.exp(latry/2), np.ones(nunique).T))
                if np.max(np.max(Etry - np.diag(np.multiply(bins, np.diag(Etry))))) &gt;= 1:
                    break
                pstry = np.divide(Etry, 1-Etry)
                glatry = np.multiply(-n*prowsunique+np.dot(pstry, vrows)-np.diag(pstry), vrows)
                errortry = np.linalg.norm(glatry)
                if errortry &lt; errorbest:
                    fbest = f
                    errorbest = errortry
            if fbest == 0:
                if lb&gt;-1000:
                    lb = lb*2
                else:
                    break

            self.la = self.la+fbest*deltala;

            if self.errors[k]/n &lt; tol:
                break

        E = np.multiply(np.outer(np.ones(nunique).T, np.exp(self.la/2)),np.outer(np.exp(self.la/2), np.ones(nunique).T))
        self.ps = np.divide(E, 1-E)
        self.gla = np.multiply(-n*prowsunique+np.dot(self.ps, vrows)-np.diag(self.ps), vrows)
        self.errors = np.append(self.errors, np.linalg.norm(self.gla))
###################################################################################################################################################################
    def getAB(self):
        mSmallestLambda = np.min(self.la)
        mLargestLambda = np.max(self.la)

        epsilon = 1e-8

        if math.fabs(mSmallestLambda) &gt; math.fabs(mLargestLambda):
            a = epsilon
            b = 3*math.fabs(mSmallestLambda)
        else:
            a = epsilon
            b = 3*math.fabs(mLargestLambda)
        return a,b
###################################################################################################################################################################
    def getExpectationFromExpLambda(self, a):
        if 1-a &lt; 1e-10:
            return 1e10
        return a/(1-a)
###################################################################################################################################################################
    def getExpectationFromPOS(self, a):
        return (1-a)/a
###################################################################################################################################################################
    def getExpectation(self, i, j, **kwargs):
        if i==j:
            return 0.0
        p = self.getPOS(i, j, **kwargs)
        # if p &lt; 1e-2:
        #     print(i, j, p)
        E = self.getExpectationFromPOS(p)
        return E
###################################################################################################################################################################
    def explambda(self, i, j):
        expL = math.exp(self.la[self.jrows[i]]/2)*math.exp(self.la[self.jrows[j]]/2)
        return expL</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="src.BackgroundDistributions.PDClass.PDClass" href="PDClass.html#src.BackgroundDistributions.PDClass.PDClass">PDClass</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="src.BackgroundDistributions.MaxEntMulti1.MaxEntMulti1U.findMaxEntDistribution"><code class="name flex">
<span>def <span class="ident">findMaxEntDistribution</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def findMaxEntDistribution(self):
    self.degrees = np.array(list(dict(sorted(dict(self.G.degree()).items())).values()))
    n = len(self.degrees)
    ######################
    prows = self.degrees/n
    prowsunique,irows,self.jrows,vrows = np.unique(prows, return_index=True, return_inverse=True, return_counts=True)
    nunique = len(prowsunique)
    bins = np.zeros(nunique)
    if irows[0] == 1:
        bins[0] == 1
    for i in range(1, nunique):
        if irows[i-1] == irows[i]-1:
            bins[i] = 1
    self.la = -np.ones(nunique)
    h = np.zeros(nunique)
    nit = 1000
    tol = 1e-14
    self.errors = np.empty(0)
    ######################
    lb = -5
    for k in range(nit):
        E = np.multiply(np.outer(np.ones(nunique).T, np.exp(self.la/2)),np.outer(np.exp(self.la/2), np.ones(nunique).T))
        ps = np.divide(E, 1-E)
        self.gla = np.multiply(-n*prowsunique+np.dot(ps, vrows)-np.diag(ps), vrows)
        self.errors = np.append(self.errors, np.linalg.norm(self.gla))

        H = 1/2*np.dot(np.dot(np.diag(vrows), np.divide(E, np.square(1-E))), np.diag(vrows))
        H = H + np.diag(np.sum(H, 0)) - 2*np.diag(np.divide(np.diag(H), vrows))
        H = H + np.dot(np.trace(H) / nunique,1e-10)

        deltala = np.linalg.solve(- H,self.gla)

        fbest = 0;
        errorbest = self.errors[k];

        for f in np.logspace(lb,1,20):
            latry=self.la+f*deltala
            Etry = np.multiply(np.outer(np.ones(nunique).T, np.exp(latry/2)),np.outer(np.exp(latry/2), np.ones(nunique).T))
            if np.max(np.max(Etry - np.diag(np.multiply(bins, np.diag(Etry))))) &gt;= 1:
                break
            pstry = np.divide(Etry, 1-Etry)
            glatry = np.multiply(-n*prowsunique+np.dot(pstry, vrows)-np.diag(pstry), vrows)
            errortry = np.linalg.norm(glatry)
            if errortry &lt; errorbest:
                fbest = f
                errorbest = errortry
        if fbest == 0:
            if lb&gt;-1000:
                lb = lb*2
            else:
                break

        self.la = self.la+fbest*deltala;

        if self.errors[k]/n &lt; tol:
            break

    E = np.multiply(np.outer(np.ones(nunique).T, np.exp(self.la/2)),np.outer(np.exp(self.la/2), np.ones(nunique).T))
    self.ps = np.divide(E, 1-E)
    self.gla = np.multiply(-n*prowsunique+np.dot(self.ps, vrows)-np.diag(self.ps), vrows)
    self.errors = np.append(self.errors, np.linalg.norm(self.gla))</code></pre>
</details>
</dd>
<dt id="src.BackgroundDistributions.MaxEntMulti1.MaxEntMulti1U.getExpectation"><code class="name flex">
<span>def <span class="ident">getExpectation</span></span>(<span>self, i, j, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getExpectation(self, i, j, **kwargs):
    if i==j:
        return 0.0
    p = self.getPOS(i, j, **kwargs)
    # if p &lt; 1e-2:
    #     print(i, j, p)
    E = self.getExpectationFromPOS(p)
    return E</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="src.BackgroundDistributions.PDClass.PDClass" href="PDClass.html#src.BackgroundDistributions.PDClass.PDClass">PDClass</a></b></code>:
<ul class="hlist">
<li><code><a title="src.BackgroundDistributions.PDClass.PDClass.explambda" href="PDClass.html#src.BackgroundDistributions.PDClass.PDClass.explambda">explambda</a></code></li>
<li><code><a title="src.BackgroundDistributions.PDClass.PDClass.explambdaIncLprev" href="PDClass.html#src.BackgroundDistributions.PDClass.PDClass.explambdaIncLprev">explambdaIncLprev</a></code></li>
<li><code><a title="src.BackgroundDistributions.PDClass.PDClass.explambdaIncLprevButDropSomeLas" href="PDClass.html#src.BackgroundDistributions.PDClass.PDClass.explambdaIncLprevButDropSomeLas">explambdaIncLprevButDropSomeLas</a></code></li>
<li><code><a title="src.BackgroundDistributions.PDClass.PDClass.explambdaMultiplier" href="PDClass.html#src.BackgroundDistributions.PDClass.PDClass.explambdaMultiplier">explambdaMultiplier</a></code></li>
<li><code><a title="src.BackgroundDistributions.PDClass.PDClass.findDistribution" href="PDClass.html#src.BackgroundDistributions.PDClass.PDClass.findDistribution">findDistribution</a></code></li>
<li><code><a title="src.BackgroundDistributions.PDClass.PDClass.getAB" href="PDClass.html#src.BackgroundDistributions.PDClass.PDClass.getAB">getAB</a></code></li>
<li><code><a title="src.BackgroundDistributions.PDClass.PDClass.getExpectationFromExpLambda" href="PDClass.html#src.BackgroundDistributions.PDClass.PDClass.getExpectationFromExpLambda">getExpectationFromExpLambda</a></code></li>
<li><code><a title="src.BackgroundDistributions.PDClass.PDClass.getExpectationFromPOS" href="PDClass.html#src.BackgroundDistributions.PDClass.PDClass.getExpectationFromPOS">getExpectationFromPOS</a></code></li>
<li><code><a title="src.BackgroundDistributions.PDClass.PDClass.getPOS" href="PDClass.html#src.BackgroundDistributions.PDClass.PDClass.getPOS">getPOS</a></code></li>
<li><code><a title="src.BackgroundDistributions.PDClass.PDClass.updateDistribution" href="PDClass.html#src.BackgroundDistributions.PDClass.PDClass.updateDistribution">updateDistribution</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="src.BackgroundDistributions" href="index.html">src.BackgroundDistributions</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="src.BackgroundDistributions.MaxEntMulti1.MaxEntMulti1D" href="#src.BackgroundDistributions.MaxEntMulti1.MaxEntMulti1D">MaxEntMulti1D</a></code></h4>
<ul class="">
<li><code><a title="src.BackgroundDistributions.MaxEntMulti1.MaxEntMulti1D.findMaxEntDistribution" href="#src.BackgroundDistributions.MaxEntMulti1.MaxEntMulti1D.findMaxEntDistribution">findMaxEntDistribution</a></code></li>
<li><code><a title="src.BackgroundDistributions.MaxEntMulti1.MaxEntMulti1D.getExpectation" href="#src.BackgroundDistributions.MaxEntMulti1.MaxEntMulti1D.getExpectation">getExpectation</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="src.BackgroundDistributions.MaxEntMulti1.MaxEntMulti1U" href="#src.BackgroundDistributions.MaxEntMulti1.MaxEntMulti1U">MaxEntMulti1U</a></code></h4>
<ul class="">
<li><code><a title="src.BackgroundDistributions.MaxEntMulti1.MaxEntMulti1U.findMaxEntDistribution" href="#src.BackgroundDistributions.MaxEntMulti1.MaxEntMulti1U.findMaxEntDistribution">findMaxEntDistribution</a></code></li>
<li><code><a title="src.BackgroundDistributions.MaxEntMulti1.MaxEntMulti1U.getExpectation" href="#src.BackgroundDistributions.MaxEntMulti1.MaxEntMulti1U.getExpectation">getExpectation</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.3</a>.</p>
</footer>
</body>
</html>